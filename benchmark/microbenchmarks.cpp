#include <math.h>
#include <stdio.h>
#include <times.h>
#include <unistd.h>

#include <algorithm>
#include <cassert>
#include <deque>
#include <experimental/random>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <set>
#include <sstream>
#include <vector>

#include "adj_list.h"
#include "benchmark_definitions.h"
#include "command_line.h"
#include "common.h"
#include "edgekey.h"
#include "graph_engine.h"
#include "graph_exception.h"
#include "platform_atomics.h"
#include "standard_graph.h"
#include "times.h"

// Microbenchmark 1: Seek latency in WT graphs and comparing that to a CSR
// Microbenchmark 2: Scan latency in the Adjacncey List received from different
// iterators and comparing that to a CSR

class CSR
{
   private:
    std::vector<int> offsets;
    std::vector<int> edges;

   public:
    int num_vertices;
    int num_edges;
    CSR(int num_vertices, int num_edges)
    {
        this->num_vertices = num_vertices + 1;
        this->num_edges = num_edges;
        this->offsets.reserve(num_vertices);
        this->edges.reserve(num_edges);
    }

    int get_vertex_degree(int vertex)
    {
        return this->offsets[vertex + 1] - this->offsets[vertex];
    }

    void adjacency_to_csr(std::vector<std::vector<int>> &adjacency_list)
    {
        int offset = 0;
        for (std::size_t i = 0; i < adjacency_list.size(); i++)
        {
            this->offsets.push_back(offset);
            for (std::size_t j = 0; j < adjacency_list[i].size(); j++)
            {
                this->edges.push_back(adjacency_list[i][j]);
                offset++;
            }
        }
        this->offsets.push_back(offset);
    }

#pragma GCC push_options
#pragma GCC optimize("O0")
    std::vector<long double> seek_and_scan(int vertex)
    {
        std::vector<long double> results;
        Times timer;
        timer.start();
        [[maybe_unused]] int degree =
            offsets[vertex + 1] - offsets[vertex];  // seek time
        timer.stop();
        results.push_back(degree);
        results.push_back(timer.t_nanos());

        timer.start();
        [[maybe_unused]] int element;
        for (int i = this->offsets[vertex]; i < this->offsets[vertex + 1]; i++)
        {
            element = this->edges[i];  // do nothing
        }
        timer.stop();
        results.push_back(timer.t_nanos());
        return results;
    }
#pragma GCC pop_options

    std::vector<int> get_edges(int vertex)
    {
        std::vector<int> result;
        for (int i = this->offsets[vertex]; i < this->offsets[vertex + 1]; i++)
        {
            result.push_back(this->edges[i]);
        }
        return result;
    }

    void print_csr()
    {
        std::cout << "Offsets: ";
        for (std::size_t i = 0; i < this->offsets.size(); i++)
        {
            std::cout << this->offsets[i] << " ";
        }
        std::cout << std::endl;
        std::cout << "Edges: ";
        for (std::size_t i = 0; i < this->edges.size(); i++)
        {
            std::cout << this->edges[i] << " ";
        }
        std::cout << std::endl;

        for (std::size_t i = 0; i < this->offsets.size() - 1; i++)
        {
            std::cout << "Vertex " << i << " has edges: ";
            for (int j = this->offsets[i]; j < this->offsets[i + 1]; j++)
            {
                std::cout << this->edges[j] << " ";
            }
            std::cout << std::endl;
        }
    }
};

void profile_csr(int num_vertices,
                 int num_edges,
                 std::filesystem::path graphfile,
                 int num_random_samples,
                 CSR &csr)
{
    std::set<int> random_vertices;

    // select random nodes
    std::random_device rd;   // a seed source for the random number engine
    std::mt19937 gen(rd());  // mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(0, num_vertices - 1);

    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [1, 6]
    for (int n = 0; n < num_random_samples; ++n)
    {
        int rando = distrib(gen);
        if (random_vertices.find(rando) == random_vertices.end())
        {
            if (csr.get_vertex_degree(rando) > 0)
            {
                random_vertices.insert(rando);
            }
            else
            {
                n--;
            }
        }
        else
        {
            n--;
        }
    }
    // create file for csr seek and scan times
    char outfile_name[256];

    sprintf(outfile_name, "%s_csr_ubench.txt", graphfile.stem().c_str());
    std::cout << outfile_name << std::endl;
    std::ofstream csr_seek_scan_outfile(outfile_name);

    csr_seek_scan_outfile
        << "\nvertex id, degree, seek time(ns),scan time per edge(ns)"
        << std::endl;
    for (int sample : random_vertices)
    {
        std::vector<long double> time = csr.seek_and_scan(sample);
        csr_seek_scan_outfile << sample << "\t" << time[0] << "\t" << time[1]
                              << "\t" << time[2] / time[0] << std::endl;
    }
    csr_seek_scan_outfile.close();
}

class WT_AdjList
{
   private:
    graph_opts opts;
    GraphEngine *graphEngine;
    WT_CONNECTION *conn;
    WT_SESSION *session;
    AdjList graph;

   public:
    // We assume that the DB has already been created and populated. We just
    // need to open it.
    WT_AdjList(std::string db_dir, std::string db_name)
    {
        opts.create_new = false;
        opts.optimize_create = false;
        opts.is_directed = true;
        opts.read_optimize = true;
        opts.is_weighted = false;
        opts.type = GraphType::Adj;
        opts.db_dir = db_dir;
        opts.db_name = db_name;
        opts.conn_config = "cache_size=10GB";
        std::cout << "GRAPH_PROJECT_DIR not set. Using CWD" << std::endl;
        opts.stat_log = "./";
        GraphEngine::graph_engine_opts engine_opts{.num_threads = 16,
                                                   .opts = opts};
        graphEngine = new GraphEngine(engine_opts);
        conn = graphEngine->get_connection();
        if (CommonUtil::open_session(conn, &session) != 0)
        {
            throw GraphException("Cannot open session");
        }
        graph = AdjList(opts, conn);
    }

    std::vector<long double> seek_and_scan(int vertex)
    {
        std::vector<long double> results;
        WT_CURSOR *adj_cursor = graph.get_out_adjlist_cursor();

        // warm the WT_Cache
        while (adj_cursor->next(adj_cursor) == 0)
        {
            int key;
            CommonUtil::get_key(adj_cursor, &key);
        }

        // seek
        Times timer;
        timer.start();
        CommonUtil::set_key(adj_cursor, vertex);
        int ret = adj_cursor->search(adj_cursor);
        if (ret != 0)
        {
            std::cout << "Vertex " << vertex << " not found" << std::endl;
            exit(1);
        }
        timer.stop();
        results.push_back(timer.t_nanos());

        // scan
        adjlist adj_list;
        timer.start();
        CommonUtil::record_to_adjlist(session, adj_cursor, &adj_list);
        for (int node : adj_list.edgelist)
        {
            // do nothing
        }
        timer.stop();
        results.push_back(timer.t_nanos());
        return results;
    }
};

void profile_wt_adjlist(int num_vertices,
                        int num_edges,
                        std::filesystem::path graphfile,
                        int num_random_samples,
                        WT_AdjList &graph)
{
    std::set<int> random_vertices;

    // select random nodes
    std::random_device rd;   // a seed source for the random number engine
    std::mt19937 gen(rd());  // mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(0, num_vertices - 1);

    // Use distrib to transform the random unsigned int
    // generated by gen into an int in [1, 6]
    for (int n = 0; n < num_random_samples; ++n)
    {
        int rando = distrib(gen);
        if (random_vertices.find(rando) == random_vertices.end())
        {
            random_vertices.insert(rando);
        }
        else
        {
            n--;
        }
    }
    // create file for csr seek and scan times
    char outfile_name[256];

    sprintf(outfile_name, "%s_adjlist_ubench.txt", graphfile.stem().c_str());
    std::ofstream csr_seek_scan_outfile(outfile_name);

    csr_seek_scan_outfile
        << "\nvertex id, degree, seek time(ns),scan time per edge(ns)"
        << std::endl;
    for (int sample : random_vertices)
    {
        std::vector<long double> time = graph.seek_and_scan(sample);
        csr_seek_scan_outfile << sample << "\t" << time[0] << "\t" << time[1]
                              << "\t" << time[2] / time[0] << std::endl;
    }
    csr_seek_scan_outfile.close();
}

int main(int argc, char *argv[])
{
    if (argc != 6)
    {
        std::cout << "Usage: ./ubenchmark <num_vertices> <num_edges> "
                     "<graphfile> <wt_db_dir> <wt_db_name>"
                  << std::endl;
        return 0;
    }
    int num_vertices = atoi(argv[1]);
    int num_edges = atoi(argv[2]);
    std::filesystem::path graphfile(argv[3]);
    string wt_db_dir(argv[4]);
    std::string wt_db_name = argv[5];
    int num_random_samples = 1000;

    std::vector<std::vector<int>> adjacency_list;
    adjacency_list.reserve(num_vertices);

    // read a graph from a file
    // check if file exists
    if (!std::filesystem::exists(graphfile))
    {
        std::cout << "File does not exist" << std::endl;
        return 0;
    }
    std::ifstream infile(graphfile);
    std::string line;
    int current_src = -1;
    std::vector<int> temp;
    int line_num = 0;
    std::vector<int> empty_vec;
    while (std::getline(infile, line))
    {
        std::istringstream iss(line);
        int a, b;
        if (!(iss >> a >> b))
        {
            break;
        }
        if (line_num == 0)
        {
            current_src = a;
        }
        if (a != current_src)
        {
            adjacency_list.push_back(temp);
            temp.clear();
            if (a != current_src + 1)
            {
                for (int i = current_src + 1; i < a; i++)
                {
                    adjacency_list.push_back(empty_vec);
                }
            }
            current_src = a;
            temp.push_back(b);
            line_num++;
        }
        else
        {
            temp.push_back(b);
            line_num++;
        }
    }
    adjacency_list.push_back(temp);

    CSR csr(num_vertices, num_edges);
    csr.adjacency_to_csr(adjacency_list);
    // csr.print_csr();

    // Profile the CSR
    profile_csr(num_vertices, num_edges, graphfile, num_random_samples, csr);

    // Profile the WT_AdjList
    std::cout << "Graphfile: " << graphfile << "\nWT dir: " << wt_db_dir
              << "\nWT name: " << wt_db_name << std::endl;

    WT_AdjList graph(wt_db_dir, wt_db_name);
    profile_wt_adjlist(
        num_vertices, num_edges, graphfile, num_random_samples, graph);
}
